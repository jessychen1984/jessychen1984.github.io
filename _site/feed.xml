<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://jessychen1984.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jessychen1984.github.io/" rel="alternate" type="text/html" /><updated>2020-03-24T08:27:40+08:00</updated><id>https://jessychen1984.github.io/feed.xml</id><title type="html">KiwiJia Blog</title><subtitle>This is KiwiJia's blog</subtitle><entry><title type="html">MiniProj之简单计算题出题器</title><link href="https://jessychen1984.github.io/2020/03/23/calculate-generator/" rel="alternate" type="text/html" title="MiniProj之简单计算题出题器" /><published>2020-03-23T00:00:00+08:00</published><updated>2020-03-23T00:00:00+08:00</updated><id>https://jessychen1984.github.io/2020/03/23/calculate-generator</id><content type="html" xml:base="https://jessychen1984.github.io/2020/03/23/calculate-generator/">最近，家有小儿初长成。曾经萌萌哒的Sam小盆友也马上要步入小学生的行列了。为了不输在起跑线上，老母亲决定每天给出100题计算题😏。手动出题太麻烦，肿么办？当然是动手写一个了！用上伟大的**Python**，分分钟搞定不在话下：

```python
'''
A simple python calculation question generator
usg: python calculator.py -d &quot;+,-&quot; -c 3 -l 200 -t 100
usg: python calculator.py --op_type=&quot;+,-&quot; --op_count=3 --limit=20 --total=100
'''
import sys, getopt, random

def auto_cal_generator(limit=100, op_count=1, op_type=[&quot;+&quot;], total=100):
    print(&quot;Here are today's %d works, good luck!&quot; % total)
    l = len(op_type)-1
    for j in range(0, total):
        up = limit
        question = &quot;&quot;
        for i in range(0, op_count+1):
            num = random.randint(1,max(1,min(limit,up))) 
            if i == 0:
                question = &quot;%s%d&quot; % (question, num)
                up -= num
                continue
            op_i = random.randint(0,l)
            op = op_type[op_i]
            question = &quot;%s%s%d&quot; % (question, op, num)
            if op ==&quot;+&quot;:
                up -= num
            elif op == &quot;-&quot;:
                up += num
            else:
                print(&quot;operator error: %s&quot; % op)
                sys.exit(1)
        
        print(&quot;%d: %s=&quot; % (j+1, question))

def main(argv=None):
    if argv is None:
        argv = sys.argv
    opts, _dummy = getopt.getopt( sys.argv[1:], &quot;l:c:d:t:&quot;, [&quot;limit=&quot;,&quot;op_count=&quot;,&quot;op_type=&quot;,&quot;total=&quot;])
    limit = 100
    op_count = 1
    op_type = [&quot;+&quot;]
    total = 100
    
    for opt,arg in opts:
        if opt in [&quot;-l&quot;, &quot;--limit&quot;]:
            limit = int(arg)
        elif opt in [&quot;-c&quot;, &quot;--op_count&quot;]:
            op_count = int(arg)
        elif opt in [&quot;-d&quot;, &quot;--op_type&quot;]:
            op_type = arg.strip().split(&quot;,&quot;)
        elif opt in [&quot;-t&quot;, &quot;--total&quot;]:
            total = int(arg)

    auto_cal_generator(limit, op_count, op_type, total)

if __name__ == '__main__':
    main()  
```

有了这个神器后，想看电视？想吃冰激凌？想去游乐园？先做30题解锁，用法：

```shell
#出30题200以内3个运算符的加减法计算
python calculator.py -d &quot;+,-&quot; -c 3 -l 200 -t 30
```

看看结果：

![auto_cal_q](/img/in-post/MiniProj/auto_cal_q.png)

当然，对于不到一年级的小豆包来说，用加减法对付已经戳戳有余了，乘除法等有空再加吧。

项目代码[点此](https://github.com/jessychen1984/MiniProj/blob/master/src/misc/calculator.py)下载</content><author><name>jessychen</name></author><category term="Python" /><category term="CS" /><category term="MiniProj" /><summary type="html">最近，家有小儿初长成。曾经萌萌哒的Sam小盆友也马上要步入小学生的行列了。为了不输在起跑线上，老母亲决定每天给出100题计算题😏。手动出题太麻烦，肿么办？当然是动手写一个了！用上伟大的Python，分分钟搞定不在话下：</summary></entry><entry><title type="html">Airflow中的路径选择</title><link href="https://jessychen1984.github.io/2020/03/22/python-branch/" rel="alternate" type="text/html" title="Airflow中的路径选择" /><published>2020-03-22T00:00:00+08:00</published><updated>2020-03-22T00:00:00+08:00</updated><id>https://jessychen1984.github.io/2020/03/22/python-branch</id><content type="html" xml:base="https://jessychen1984.github.io/2020/03/22/python-branch/">&gt; Airflow 是 Airbnb 公司开源的任务调度系统, 通过使用 Python 开发 DAG, 非常方便的调度计算任务。

Airflow之前，当多个上下游的任务间存在依赖时，需要我们自己来写一些调度的code，常用的有几种：

* 上游任务完成后置个done标记。需要下游隔段时间检查上游任务有没有完成。
* 上游完成任务后通过某个api来call下游。你说call 失败了？retry大法用起来呀​​。。。

模块太多，依赖太复杂，记不住怎么办？写个文档吧。。。上游改了？？改文档吧。。。下游又变了？？？再改。。。哎呀，上线来不及了，过几天更新吧。。。。那个文档很久没更新了，还是看code吧。。。

而Airflow使用DAG，可以很方便的通过定义**Operator**，及Operator间的关系（**upstream, downstream**）来解决任务之间的各种依赖。同时，它还提供了UI来查看任务依赖的DAG，任务运行状态。简单的说，它可以使我们更多的关注到业务的实现上而不是各种复杂的模块调用及繁琐的文档维护。

当然，作为一条完整的业务流，根据上游的执行结果来决定下游的行为是最常见不过的事了。比如👇的例子：

有个淘气的Sam小盆友，每天按时 **完成作业** 是个大难题。于是，妈妈想了个办法：

![branch-dag](/img/in-post/Airflow/branch.png)

真是个不错的法子👍！这里，`8点前写完`在Airflow里就是个判断用的task，由它来决定整个DAG的下一步操作。那么，怎么实现呢？Airflow提供了**BranchPythonOperator**，用来支持分支, 通过函数返回要执行的分支。

```python
check_hour_op = BranchPythonOperator(
  task_id = &quot;check_hour&quot;,
  python_callable = check_hour,
  dag = dag
)
def check_hour(){
  if current_hour &gt; 8:
    return &quot;sleep&quot;
  else:
    return &quot;watch_animation&quot;
}
do_homework_op &gt;&gt; check_hour_op &gt;&gt; [watch_animation_op, sleep_op]
watch_animation_op &gt;&gt; sleep_op
```

Ok👏 简直太简单了！执行一下试试，然后你会发现，当`check_hour`返回`watch_animation`时，`sleep`这个task的状态永远是skip的？？？让我们翻一下官方的解释：

&gt; Note that using tasks with `depends_on_past=True` downstream from `BranchPythonOperator` is logically unsound as `skipped` status will invariably lead to block tasks that depend on their past successes. `skipped` states propagates where all directly upstream tasks are `skipped`.

就是说，`sleep`这个task在`check_hour`选择了`watch_animation`的时候就被skip掉了，即便这里它是`watch_animation`的下游任务，仍然不会被执行😭。原因呢？官方说是downstream设了*depends_on_past=True*。要知道，operator中还有个属性叫*trigger_rule*，默认值是*all_success*。这两个组合在一起就要上游的task状态都为*success*才能继续往下执行。而这里`sleep`的上游任务`watch_animation`状态是*skipped*, 所以`sleep`就没有被执行到了。那么，如果这里我们把`sleep`的*trigger_rule*置成*none_failed*的话，整个过程就能按我们预期的执行下去了:

```python
sleep_op = PythonOperator(
  task_id = &quot;sleep&quot;,
  trigger_rule = &quot;none_failed&quot;,
  python_callable = &quot;sleep&quot;,
  dag = dag
)
```

再试一下，果然可以啦:satisfied:

Airflow现在支持的Trigger Rules:

&gt; ALL_SUCCESS = 'all_success'
&gt; ALL_FAILED = 'all_failed' 
&gt; ALL_DONE = 'all_done' 
&gt; ONE_SUCCESS = 'one_success' 
&gt; ONE_FAILED = 'one_failed' 
&gt; NONE_FAILED = 'none_failed' 
&gt; NONE_SKIPPED = 'none_skipped' 
&gt; DUMMY = 'dummy'

除了上面这个方法，我们也可以利用**DummyOperator**来达到想要的效果。也就是在`watch_animation`平行的分支上加一个`dummy`task，它啥活都不干：

```python
dummp_op = DummyOperator(
	task_id = &quot;dummy&quot;,
  dag = dag
)
do_homework_op &gt;&gt; check_hour_op &gt;&gt; [watch_animation_op, dummp_op]
watch_animation_op &gt;&gt; sleep_op
dummp_op &gt;&gt; sleep_op
```

这种方式更简单易懂，代价就是会稍稍增加些代码，喜欢哪个就仁者见仁了:smirk:。</content><author><name>jessychen</name></author><category term="Airflow" /><category term="CS" /><summary type="html">Airflow 是 Airbnb 公司开源的任务调度系统, 通过使用 Python 开发 DAG, 非常方便的调度计算任务。</summary></entry></feed>